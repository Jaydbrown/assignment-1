# assignment-1

Where Structs, Mappings and Arrays Are Stored
Every state variable you declare at the top level of a contract lives in storage. Storage is a persistent key-value store that is part of the Ethereum world state. It survives across transactions and is permanently tied to the contract's address on the blockchain. When you declare a mapping or an array at the contract level, you are allocating a slot in storage. The EVM assigns each state variable a storage slot starting from slot 0. Mappings and dynamic arrays do not store their data contiguously in these slots. Instead, the slot holds metadata or a length, and the actual values are stored at positions derived by hashing the key with the slot number using keccak256.
Structs that are declared as state variables also live in storage. Their fields are packed into storage slots sequentially. If fields are small enough, the EVM will pack multiple fields into a single 32-byte slot to save gas.
Local variables inside functions behave differently. They live in memory, which is a temporary, linear byte array that only exists during the execution of a function call and is wiped clean after the call ends. When you declare a struct or array inside a function and mark it as memory, it gets allocated in this temporary space. Stack variables such as uint256 or address local values live on the EVM call stack, which holds up to 1024 values and is even cheaper to access than memory.
Calldata is a third location. It is a read-only area that holds the encoded input data of an external function call. Using calldata for function parameters instead of memory avoids copying the data and saves gas.
How They Behave When Executed or Called
When a function reads a storage variable, the EVM executes a SLOAD opcode which costs 2100 gas cold and 100 gas warm. When it writes, it executes SSTORE which costs up to 20000 gas for writing to a zero slot and 2900 gas for updating an existing slot. This makes storage the most expensive data location by far.
Reading and writing to memory costs only 3 gas per 32 bytes for the first 724 bytes, expanding quadratically after that. This is why you should use memory for intermediate computations inside functions and only persist what you need to storage.
When you access a mapping with a key, the EVM computes keccak256(key . slot) to find where the value lives in storage. The dot here means concatenation of the ABI-encoded key and the slot number as 32-byte values. For nested mappings like mapping(address => mapping(address => uint256)), this hashing is applied twice. The lookup always returns a value even for keys that have never been set, returning zero as the default.
Dynamic arrays in storage store their length at their assigned slot and place elements starting at keccak256(slot). Accessing an element at index i means reading from keccak256(slot) + i. Pushing to a dynamic array increments the length and writes to the next computed position.
Why You Do Not Need to Specify Memory or Storage with Mappings
Mappings can only ever exist in storage. The EVM has no mechanism to represent a mapping in memory or calldata. A mapping is not a contiguous block of data you can copy or pass around. It is a logical abstraction over the entire 2^256 storage space, where values are accessed by a deterministic hash of their key. There is no such hashing mechanism in the memory or calldata models.
Because of this constraint, the compiler already knows a mapping must be in storage. Requiring you to write storage mapping(...) would be redundant. The Solidity compiler enforces this and will reject any attempt to declare a mapping in memory. The same restriction applies to mappings inside structs. If a struct contains a mapping, that struct can only be placed in storage as well, because the mapping field cannot be copied to memory.
